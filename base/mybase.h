// 避免编译时重复声明报错，这里使用ifndef创建一个全局变量
#ifndef MYBASE_H
#define MYBASE_H

// #pragma once表示当前头文件只编译一次，后面再在同一个文件中include多次的时候，也只会编译一次。
#pragma once

// 声明变量
int std_declare_var_in_head_file1;

// 声明并初始化变量
int std_declare_var_in_head_file2 = 1;

// 声明函数
void std_declare_func_in_head_file(char *s);


/* 使用 #pragma pack(4) 实现内存对齐
 *      背景：
 *          计算机总线每次能够传输的数据大小是一个"字"，字的大小一般是4个字节或者8个字节（跟机器有关系）。
 *          现在计算机内存空间都是按照byte字节划分的，理论上讲对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的
 *              时候经常在特定的内存地址上访问，这就需要各种数据类型按照一定的规则在空间上排列，而不是一个接一个的排放(即：不是我们想象
 *              中的那么非常紧凑的存储)，这就是内存对齐。
 *      为什么要内存对齐？
 *          1. cpu对内存的读取不是连续的而是分块读取的，块的大小只能是2i个字节数，从cpu的读取性能和效率来考虑，
 *             若读取的数据未对齐，则需要两次总线周期来访问内存，因而效率会大打折扣
 *          2. 另外某些固定的硬件平台只能从规定的相对地址处读取特定类型的数据，否则会产生硬件异常。如果不按照适合平台要求对数据存放进行对齐，
 *             会存在效率上的损失。比如有些平台每次读都是从偶地址开始，如果一个int型（32位系统）存放在偶地址开始的地方，那么一个周期就可以
 *             读出这32bit，而如果存放在奇地址开始的地方，就需要两个读周期，并对两次读出结果的高低字节进行拼凑才能得到该32bit数据。显然在
 *             读取效率上下降很多。
 *
 *       参考：https://www.cnblogs.com/southcyy/p/10175163.html
 */
#pragma pack(4)
struct Demo{            // 内存对齐之后实际占用内存 8字节
    char s;             // s由于只有1个字节，但是由于要对齐，所以需要偏移3个字节，也就是说还需要额外3个字节的空间才能保证对齐，
                        // 所以m是从第四个变量开始的。所以这里即使再额外定义3个char变量，总共也是占用8个字节
    int32_t m;
};

struct Demo2{            // 内存对齐之后实际占用内存 8字节
    char s1;
    char s2;
    char s3;
    char s4;
    int32_t m;
};

struct Demo3{            // 内存对齐之后实际占用内存 12字节
    char s1;
    char s2;
    char s3;
    char s4;
    char s5;            // s5只能放到一个新的4字节空间中
    int32_t m;
};

#endif